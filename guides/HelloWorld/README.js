Ext.data.JsonP.HelloWorld({"guide":"<h1>Hello World</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/HelloWorld-section-1'>Sneak Peek</a></li>\n<li><a href='#!/guide/HelloWorld-section-2'>Project SetUp</a></li>\n<li><a href='#!/guide/HelloWorld-section-3'>Dependencies</a></li>\n<li><a href='#!/guide/HelloWorld-section-4'>Component SetUp</a></li>\n<li><a href='#!/guide/HelloWorld-section-5'>MVC SetUp</a></li>\n<li><a href='#!/guide/HelloWorld-section-6'>Python Scaffolding Tool</a></li>\n</ol>\n</div>\n\n<p><strong>Level:</strong> Beginner</p>\n\n<h2 id='HelloWorld-section-1'>Sneak Peek</h2>\n\n<p>This is the \"Hello World\" guide to your first Strappy component.\nBy the end of this tutorial you will have created a button component,\nwhich toggles the visibility of an 'h1'-tag containing the string \"Hello World\".</p>\n\n<p><p><img src=\"guides/HelloWorld/helloWorld_hidden.png\" alt=\"Alt text\"></p></p>\n\n<br>\n\n\n<br>\n\n\n<p><p><img src=\"guides/HelloWorld/helloWorld_visible.png\" alt=\"Alt text\"></p></p>\n\n<br>\n\n\n<h2 id='HelloWorld-section-2'>Project SetUp</h2>\n\n<p>First of all, set up a new project using the IDE of your choice and name it \"Hello World\".<br>\nYou should end up with something that looks more or less like this:\n<p><img src=\"guides/HelloWorld/initialProjectSetupIDEShot.png\" alt=\"Alt text\"></p></p>\n\n<br>\n\n\n<h2 id='HelloWorld-section-3'>Dependencies</h2>\n\n<p>Strappy applications depend on the following three libraries:</p>\n\n<ol>\n<li><p><a href=\"https://github.com/SpinifexGroup/strappy/zipball/master\">Strappy framework</a> <br>\n(All the jazz that will enable you to create scaleable and maintainable projects, ranging from simple standalone components to full-blown applications.)</p></li>\n<li><p><a href=\"https://github.com/melechi/JS-Klass-Kit/zipball/master\">JSKK Classing Engine</a> <br>\n(A classing engine, straight out of our mad lab's coding oven. Strappy is based on JSKK and is the reason why you will be able write OOP without runnig into those little native JS traps. It also comes with a truckload of ready to use utils.)</p></li>\n<li><p><a href=\"http://jquery.com/\">jQuery Download Page</a> <br>\n(jQuery won't need much of introducing. Strappy depends on it and you will most likely too.)<br></p></li>\n</ol>\n\n\n<p>Now create three sub directories in your lib folder and name them \"jQuery\", \"JSKK\" and \"strappy\". <br></p>\n\n<p>Once you have extracted your compressed downloads, locate the minified versions (strappy = \"framework.min.js\"; JSKK = \"bin/jskk.min-1.0.1.js\") and place them in the appropriate sub directories you just created. <br>\nFor jQuery you will simply copy the latest minified source off the jQuery website, create a new .js file and paste the copied source into that file. Name it jquery1.x.x.js and place it in your newly created jQuery folder under lib.</p>\n\n<p>Your project outliner window should now look similar to this screenshot:</p>\n\n<p><p><img src=\"guides/HelloWorld/dependenciesImportedAndHookedUp.png\" alt=\"Alt text\"></p></p>\n\n<p>Next, hook up those libraries in your \"index.html\" file. <br>\nNOTE: The order in which those libraries are being imported matters. <br>\nStrappy depends on both - jQuery and JSSK - and therefore needs to be included last.</p>\n\n<br>\n\n\n<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Strappy - Hello World&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;script type=\"text/javascript\" src=\"lib/JSKK/jskk.min-1.0.1.js\"&gt;&lt;/script&gt;\n        &lt;script type=\"text/javascript\" src=\"lib/jQuery/jquery1.8.0.js\"&gt;&lt;/script&gt;\n        &lt;script type=\"text/javascript\" src=\"lib/strappy/framework.min.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<br>\n\n\n<br>\n\n\n<h2 id='HelloWorld-section-4'>Component SetUp</h2>\n\n<p>Now you should create a folder structure for your component.\nWe're going to use the following folder/file structure.\nCreate the folders and files in them.\nLeave the files blank for now.</p>\n\n<br>\n\n\n<pre><code>/Application/component/\n/Application/component/button/\n/Application/component/button/Button.js\n/Application/component/button/controller/\n/Application/component/button/controller/State.js\n/Application/component/button/controller/Default.js\n/Application/component/button/model/\n/Application/component/button/store/\n/Application/component/button/store/State.js\n/Application/component/button/view/\n/Application/component/button/view/Default.js\n/Application/component/button/view/html/\n/Application/component/button/view/html/default.html\n</code></pre>\n\n<br>\n\n\n<p>Your IDE project profiler window should now look something like this:</p>\n\n<br>\n\n\n<p><p><img src=\"guides/HelloWorld/manuallyScaffolded.png\" alt=\"Alt text\"></p></p>\n\n<br>\n\n\n<p>Going back to your index.html, you will of course also need to import all those still empty classes you have just created.\nSo beneath your library imports add the following</p>\n\n<br>\n\n\n<pre><code>// libraries\n// ... not displayed \n//\n// component\n&lt;script type=\"text/javascript\"  src=\"Application/component/button/Button.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"  src=\"Application/component/button/controller/Default.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"  src=\"Application/component/button/controller/State.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"  src=\"Application/component/button/store/State.js\"&gt;&lt;/script&gt;\n// if time implement an object model in order to illustrate component's basic data infrastructure  \n&lt;script type=\"text/javascript\"  src=\"Application/component/button/view/Default.js\"&gt;&lt;/script&gt;\n</code></pre>\n\n<br>\n\n\n<p>When opening \"index.html\" in your browser you should not recive any errors. <br>\nIf you do, you most likely have wired up your dependencies incorrectly or there is a typo in your links. <br>\nCheck everything thoroughly and proceed with the next step - \"MVC SetUp\".</p>\n\n<br>\n\n\n<h2 id='HelloWorld-section-5'>MVC SetUp</h2>\n\n<p>In order to instantiate your component, we will start to implement the bare minimum requirements of your component's MVC triad.</p>\n\n<br>\n\n\n<p>The first thing we will create is our base and configuration class \"Button.js\". In it you will define it's nature, descent, possible child components as well as default config settings.</p>\n\n<br>\n\n\n<p>We will then work ourselves from the bottom up - starting with the view and its html-template to the StateStore and ending in our Default and State controllers.</p>\n\n<br>\n\n\n<p>Here comes our base class - Button.js</p>\n\n<br>\n\n\n<br>\n\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'HelloWorld.component',\n        $name:      'Button',\n        $extends:   strappy.Component\n    }\n)\n(\n    {},\n    {\n        models:\n        [\n            'Default'\n        ],\n        views:\n        [\n            'Default'\n        ],\n        controllers:\n        [\n            'Default'\n        ],\n        stores:\n        [\n            // your stores in here\n        ]\n    }\n);\n</code></pre>\n\n<br>\n\n\n<br>\n\n\n<p>Walking through this code we can see that the component follows a convention for the namespace \"<Project>.component\". The name is the same as the file name,\nwhich follows the name of the folder \"HelloWorld\".</p>\n\n<br>\n\n\n<p>Also, it's extending the base component class</p>\n\n<br>\n\n\n<p>Next we see the models are defined as an array, followed by views and controllers. This enables the framework to initialize these classes so that they are ready for use by the time\nyou need to access them in either a Controller or View.</p>\n\n<br>\n\n\n<p><b>View &amp; HTML Template</b>\nThe html template we are creating is a very simple one. It only consists of a wrapping \"div\" element, which we use to position things, an \"input\" button to trigger an action and last but not least a \"h1\" which will output our \"Hello World\" in this simple example. Now this template is neither realistic nor does it make much sense - all we are after is a proof of concept. I an real world example i twould probably more likely to separate those two elements and make two individual components, which are detached from each other and could be extended or be reused multiple times. Here however, we need only one very specific function and in order to keep the scope of this \"Hello World\" example to a minimum we favor simplicity over correctness.</p>\n\n<p>Ok, here we go. This is your 'default.html':</p>\n\n<p>HTML:</p>\n\n<pre><code>&lt;div class=\"myHolder\"&gt;\n    &lt;h1 class=\"hidden myOutlet\"&gt;HELLO WORLD&lt;/h1&gt;\n    &lt;input class=\"myButton\" type=\"button\" value=\"show me\"&gt;\n&lt;/div&gt;\n</code></pre>\n\n<br>\n\n\n<p>Now this template will be administered by your view class, which looks like this:</p>\n\n<p>Default.js:</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'HelloWorld.component.button.view',\n        $name:      'Default',\n        $extends:   strappy.mvc.View\n    }\n)\n(\n    {},\n    {\n        templates:\n        {\n            Default:        'default.html'\n        },\n\n        //  list properties here\n\n        // list methods here\n\n        onReady: function()\n        {\n            this.bindDOMEvents();\n        },\n\n        onShow: function()\n        {\n            // something here\n        },\n\n        bindDOMEvents: function()\n        {\n            this.bindContainerEvent('click.button',  'controller:Default', 'onButtonClicked');\n        },\n\n        onModelLockChange: function(signal)\n        {\n            // something here\n        },\n\n        syncView: function()\n        {\n            // something here\n        },\n\n        updateOutlet: function(isVisible)\n        {\n            var outlet = $(\".myOutlet\", this.getContainer()),\n                button = $(\".myButton\", this.getContainer());\n            switch(isVisible)\n            {\n                case true:\n                    button.val(\"hide me\");\n                    outlet.removeClass('hidden');\n                    break;\n\n                case false:\n                    button.val(\"show me\");\n                    outlet.addClass('hidden');\n                    break;\n            }\n        }\n    }\n);\n</code></pre>\n\n<p>Let's have a look at the code:</p>\n\n<p>The head section gives infos about your class - where it belongs, its name and what it extends.\nThe \"templates\" object sole purpose is to list your view's html templates. Yes your view can orchestrate more than one template and switch between them as needed. But more about that later. \"Hello World\" needs only one simple template to work.</p>\n\n<p>The \"onReady\" method is automatically called when your view is ready to receive instructions. Here you usually call your init methods to setup your view. In this case we are only concerned about binding DOM events to your container. Therea are two different ways of binding DOM events in strappy. One binds events to a specific HTML element and the other binds it to your view's container. Every component owning a view also comes with a HTML element called the container. As the name already suggests, it's sole purpose is to hold your templates. So when you should decide to swap templates, the holder will remain constant and addressable. So here we are binding a container event for simplicity, as we don't need to specify a particular element. this is not a clean way of attaching a click event which is supposed to have only one specific target, but illustrates beauitfully how the contianer element has the whole template as target. When \"Hello World\" is finished you will see that pressing the h1 tag wil also trigger the exact same action as if you were to press the button instance. Let's asses the 'bindContainerEvent' method, which takes three arguments:</p>\n\n<p>The first argument is the event specifier. 'click' is the native DOM event separated by a dot from 'button' which is a custom value add on for the event. Since javascript only deals with the event name information before the dot, one can take advantage of this fact in order to label a generic event and make itmore specific and therefore easier to identify.</p>\n\n<p>Argument number two is the instance dealing with the event callback. In this case we want our default controller to be the responder of this event, so we write: 'controller:Default'. We could also define ourself as responder and type the following: 'view:Default' if you wanted that event to be maintained and handled only by the view.\nA reason to handle this event straight away in your view could be that some event triggered does not require any other parts of your MVC to change a state or to communicate a change to other components. Event though you could achieve such thing via css, a good example might be a cursor change upon a mouseEvent triggered. The rest of your application really doesn't need to be concerned about minor, internal graphical states and can therefore be maintained by your component's view directly.</p>\n\n<p>The last parameter is the event handler method. This is the name of the method which is being called to handle the event.</p>\n\n<br>\n\n\n<p>The next two methds - onModelLockChange and syncView - need to be implemented in your view but can stay blank for now since we are not having a situation in which we either need to be notified about a model lock change nor do we need to sync our view with data received from an async call.</p>\n\n<p>\"updateOutlet\" on the other hand is again important to us. this method takes one argument \"isVisible\", which is a boolean value. \"updateOutlet\" is going to be called by our state controller class when it receives notification of a model state change. (visible or hidden) In here we are basically doing two things:</p>\n\n<p>First we are checking against the supplied argument value (true/false). Secondly, depending on the argument passed on we change the buttons value attribute to label the action taking palce on press as well as adding or removing a css attribute to our h1 tag. this attribute is a class attribute named 'hidden', which will change our elements visibility to either hidden or visible. See style.css.</p>\n\n<p><b>Store &amp; Model</b></p>\n\n<p>There's no need to create a state model as this is being handled for us automatically by the framework. So the model directory can stay empty.</p>\n\n<p>Store.js</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'HelloWorld.component.button.store',\n        $name:      'State',\n        $extends:   strappy.data.stateful.Store\n    }\n)\n(\n    {},\n    {\n        data:\n        {\n            'public':\n            {\n                // something here\n            },\n            'private':\n            {\n                isVisible: false\n            }\n        }\n    }\n);\n</code></pre>\n\n<p>Our \"Hello World\" example only has one store. The state store. If our component would hold more complex data, like a personal user profile for example with multiple fields, we could introduce an \"User\" store which is linked to a \"User\" model. This would aid us in retrieving values out of a record or perform business logic procedures on that record to maybe update that record of a user with a record that lives somewhere on a remote server. Here however, all we wanna know is a particular state of our component: visible or not. you can also see that we are having two different places to put our state data in: the 'public' and the 'private' section inside data{}.\nSince our component has no interest in sharing its internal state, we are putting our 'isVisible' property inside 'private'. NOTE: A common mistake which can be difficult to track down is that public and private are being declared without quotation marks. By convention strappy requires you to use quotations here.</p>\n\n<p><b>Controller</b></p>\n\n<p>\"Hello World\" get's two controllers to work with. A State and a Default controller. Both of which are mandatory. Strappy encourages the use of multiple controllers in order to serve the single responsibility principle. Meaning - if you as a developer delegate your specific task to specific controllers, complex components will become easier to maintain, bugs quicker to track and resolve and your code less difficult to read for other developers, that might need to revisit your code. So, having said that let's see what our Default controller does. Here's the code:</p>\n\n<p>Default.js</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace:     'HelloWorld.component.button.controller',\n        $name:          'Default',\n        $extends:       strappy.mvc.Controller\n    }\n)\n(\n    {},\n    {\n        init: function()\n        {\n            // call super\n            this.init.$parent();\n\n            /**\n             *  set observers\n             */\n            // let Default view report as soon as it's html template is loaded\n            this.getView('Default')     .observe('onTemplatesLoaded',   this.onTemplatesLoaded.bind(this));\n\n            //  let State controller report as soon as component has been all set up and is ready to go\n            this.getController('State') .observe('onReadyState',        this.onReadyState.bind(this));\n        },\n\n\n        // Observer Handlers\n        onTemplatesLoaded: function(view)\n        {\n            // append your html template to desired view\n            view.getContainer().append(view.getTemplate('Default'));\n        },\n\n        onReadyState: function()\n        {\n            // show command for your desired view\n            this.getView('Default').show();\n        },\n\n        onButtonClicked: function(event)\n        {\n            this.getStore('State').set('isVisible', !this.getStore('State').get('isVisible'));\n        }\n    }\n);\n</code></pre>\n\n<p>Inside init() we're doing three things. At first we're calling Default Controller's super init() and right after setting two observers on the events templateLoaded and ready. Both events are rather self explanatory.</p>\n\n<p>The first one is being dispatched as soon as the component's template has been loaded. in its event handler \"onTemplatesLoaded()\", we are appending our view container with the template in question. Note that this does NOT automatically display the template. In order to make it appear on screen you want to call the method show() on it.\nAnd that's exactly what we're doing in our second event handler \"onReadyState()\", which marks the component to be ready.</p>\n\n<p>We will include one last thing in our Default controller. Remember how we assigned a DOM mouse.click event in our Default view at the very beginning? The next method \"onButtonClicked()\" is its event handler. All we are doing in here is to toggle our component's internal or private state \"isVisible/<em>Boolean</em>/\" through the 'State' store we have set up in the last section \"Store &amp; Model\". And that's it for our Default controller.</p>\n\n<p>There's only one more class we have to write and that's the State controller. The state controller is basically doing two things in our example. It checks on all view and flags the component \"ready\". A state for all other MVC members of that component to react upon. Secondly it will observe state changes, which are being handled by the state store and either orchestrates or, in a simple component like this, directly calls all methods processing this piece of state information.</p>\n\n<p>If you have foolowed everything correctly you should be able to just call your page inside your favorite web browser (probably IE8) and see the amazing result.</p>\n\n<h2 id='HelloWorld-section-6'>Python Scaffolding Tool</h2>\n\n<p>Doing things by hand can be very satisfying at times...setting up generic components is not one of those things. If you aggree you might as well check out <a href=\"#!/guide/ComponentScaffolding\">Component Scaffolding Tool</a> for further reading. Our lead developer developed a pyhton tool that ships with strappy, making component creation more fun than catching gummi bears with your mouth.</p>\n\n<br> \n\n","title":"Hello World Component"});