Ext.data.JsonP.SharedEntities({"guide":"<h1>Shared Entities</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/SharedEntities-section-1'>State</a></li>\n<li><a href='#!/guide/SharedEntities-section-2'>Models</a></li>\n<li><a href='#!/guide/SharedEntities-section-3'>Stores</a></li>\n</ol>\n</div>\n\n<p><p><img src=\"guides/SharedEntities/images/ApplicationComponent.png\" alt=\"Application Component Overview\"></p></p>\n\n<p>There are three different shared entities. These are state, models and stores.</p>\n\n<h2 id='SharedEntities-section-1'>State</h2>\n\n<p>The state shared entity is a specialised store which holds global <em>private</em> state properties. It is very useful for holding cross-application state or config which is used by sub components.</p>\n\n<p>Nothing special is required to be done in order to use the shared state. Simply call the helper methods which are available in every view and controller to get or set shared state properties.</p>\n\n<p>Example:</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.component.application.controller',\n        $name:      'Default',\n        $extends:   strappy.mvc.Controller\n    }\n)\n(\n    {},\n    {\n        onReadyState: function()\n        {\n            var view=this.getView('Default');\n            if (this.getSharedState('authenticated'))\n            {\n                view.showMain();\n            }\n            else\n            {\n                view.showLogin();\n            }\n        },\n        onLogin: function(email,password)\n        {\n            this.asyncServerLogin\n            (\n                {\n                    email:      email,\n                    password:   password\n                },\n                function(response)\n                {\n                    if (response.success)\n                    {\n                        this.setSharedState('authenticated');\n                    }\n                    else\n                    {\n                        this.getView('Default').displayErrorMessage(response.message);\n                    }\n                }.bind(this);\n            );\n        }\n    }\n);\n</code></pre>\n\n<h2 id='SharedEntities-section-2'>Models</h2>\n\n<p>Shared models are useful for defining data structures which are commonly used across the application. Generally these are representations of your tables in your database, but may also include meta data for component-specific use.</p>\n\n<p>These models, and also shared stores, need to be namespaced in a \"shared\" space within your top level namespace for your project.</p>\n\n<p>Example:</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.shared.model',\n        $name:      'User',\n        $extends:   strappy.mvc.Model\n    }\n)\n(\n    {},\n    {\n        fields:\n        {\n            id:                 null,\n            email:              '',\n            password:           null,                   //Always null unless being changed.\n            last_activity:      '0000-00-00 00:00:00',\n            created:            '0000-00-00 00:00:00',\n            status:             0                       //0 - Inactive; 1 - Active\n        }\n    }\n);\n</code></pre>\n\n<p>Like normal models, they are initalised for each record in a store. So the only other work involved is to attach your shared models to stores. Keeping in mind that they can be attached to any type\nof store, be they shared or private.</p>\n\n<h2 id='SharedEntities-section-3'>Stores</h2>\n\n<p>Shared stores are one of the most useful tools in the framework. They allow you to define a store which can be plugged into any number of components. There are various ways to do them, we're going to cover them all here and explain where and why you would use each approach.</p>\n\n<p>Before we do that. This must be metioned again. Any shared store must be namespaced in a  \"shared\" space within your top level namespace for your project. Failing to do this with a shared store will render it unusable unless you manually initalise it - which defeats the purpose of shared stores.\nThis is because the component core manually initalises the <a href=\"#!/api/strappy.ShareMgr\" rel=\"strappy.ShareMgr\" class=\"docClass\">shared store manager</a>. This in turn initialises each shared store found in the shared namespace, overriding their definitions and recreating them as singletons.</p>\n\n<p>First, lets let at what a shared store looks like.</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.shared.store',\n        $name:      'Users',\n        $extends:   strappy.data.MultiModelStore\n    }\n)\n(\n    {},\n    {\n        model:      Project.shared.model.User,\n        BTL:        'Project.BTL',\n        BTL_GET:    'Project.API.user.get',\n        BTL_SET:    'Project.API.user.set'\n    }\n);\n</code></pre>\n\n<p>Note the above example is using BTL for managing the data. See the BTL guide for more information about that.</p>\n\n<p>Now let's look at how to use these stores.</p>\n\n<h3>Direct Usage</h3>\n\n<p>One way to use a shared store is to simply access it directly via its full namespace. This is generally only ever done in your applicaiton controllers. This is because child components should always be considered dumb and never try to communicate with anything outside of its scope.</p>\n\n<p>Example:</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.component.application.controller',\n        $name:      'Default',\n        $extends:   strappy.mvc.Controller\n    }\n)\n(\n    {},\n    {\n        onReadyState: function()\n        {\n            //Sync the system users so we can show a table of them...\n            Project.shared.store.Users.sync();\n            this.getView('Default').drawUsersTable();\n        }\n    }\n);\n</code></pre>\n\n<h3>Attaching</h3>\n\n<p>Another way is to attach the stores \"as is\" directly to the component.</p>\n\n<p>The best way to do this is by overriding the component's configure method and observing when the component has been configured.</p>\n\n<p>This is almost always done when a child component needs to be dynamically configured with a store. This is generally the case for generic components, as they should never know their data\nsource until it is provided to them during thier configuration phase.</p>\n\n<p>Below is a good example of how this can be done.</p>\n\n<p>Example:</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.component',\n        $name:      'Grid',\n        $extends:   strappy.Component\n    }\n)\n(\n    {},\n    {\n        config:\n        {\n            signalKey:              null,\n            columnStore:            null,\n            recordStore:            null\n        },\n        components: {},\n        stores:     [],\n        views:\n        [\n            'Default'\n        ],\n        controllers:\n        [\n            'Default'\n        ],\n        configure: function(newConfig)\n        {\n            this.observeOnce\n            (\n                'onConfigured',\n                function()\n                {\n                    this.attachSharedStore('Columns',this.getConfig('columnStore'));\n                    this.attachSharedStore('Records',this.getConfig('recordStore'));\n                }.bind(this)\n            );\n            this.configure.$parent(newConfig);\n        }\n    }\n);\n</code></pre>\n\n<h3>Binding &amp; Extending</h3>\n\n<p>Finally, there is a way in which you can create a component level store and tell it to share all the properties and funtionality from another store.</p>\n\n<p>The great thing about this feature is that it isn't limited to shared stores. Techincally you can tell it to share from any store application-wide, but for best practices it is encouraged that you only share from shared stores.</p>\n\n<p>Below is an example of how its done.</p>\n\n<p>Example:</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.component.application.store',\n        $name:      'Users',\n        $extends:   strappy.data.MultiModelStore\n    }\n)\n(\n    {},\n    {\n        sharedFrom: 'Project.shared.store.Users'\n    }\n);\n</code></pre>\n\n<p>So as you can see, its pretty straight forward. Simply define a \"sharedFrom\" property on your store and it will behave as if it were that shared store. This is completely transparent to the rest of your code, so you simply access the store as you usually would.</p>\n\n<p>Example:</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.component.application.view',\n        $name:      'Default',\n        $extends:   strappy.mvc.Controller\n    }\n)\n(\n    {},\n    {\n        drawUsersTable: function()\n        {\n            var wrapper=$(\n                [\n                    '&lt;table&gt;',\n                        '&lt;tr&gt;',\n                            '&lt;th&gt;Email&lt;/th&gt;',\n                            '&lt;th&gt;Last Active&lt;/th&gt;',\n                            '&lt;th&gt;Created&lt;/th&gt;',\n                        '&lt;/tr&gt;',\n                    '&lt;/table&gt;'\n                ].join(''));\n            this.getStore('Users').each\n            (\n                function(record)\n                {\n                    wrapper.append\n                    (\n                        [\n                            '&lt;tr&gt;',\n                                '&lt;td&gt;'+record.get('email')+'&lt;/td&gt;',\n                                '&lt;td&gt;'+record.get('last_activity')+'&lt;/td&gt;',\n                                '&lt;td&gt;'+record.get('created')+'&lt;/td&gt;',\n                            '&lt;/tr&gt;'\n                        ].join('')\n                    );\n                }.bind(this)\n            );\n            this.getContainer() .html('')           //Empty\n                                .append(wrapper);   //Insert\n        }\n    }\n);\n</code></pre>\n\n<p>So that's all pretty simple stuff and works really well. But the real power of using shared from comes from the ability to override and add additional functionality to that store instance and leave the shared store unaffected by the additions.</p>\n\n<p>Let's have a look at some examples of this in action.</p>\n\n<p>First, let's assume that we want our view to only show active users, but we don't want to put that logic into the view. We'll extend the store to provide this functionality.</p>\n\n<pre><code>$JSKK.Class.create\n(\n    {\n        $namespace: 'Project.component.application.store',\n        $name:      'Users',\n        $extends:   strappy.data.MultiModelStore\n    }\n)\n(\n    {},\n    {\n        sharedFrom: 'Project.shared.store.Users',\n\n        //Override the each method.\n        each: function(callback)\n        {\n            this.find({status:1}).each(callback);\n            return this;\n        }\n    }\n);\n</code></pre>\n\n<p>Now the next time that the \"drawUsersTable\" method is called, only users with a status of 1 (active), will be shown.</p>\n","title":"Shared Entities"});